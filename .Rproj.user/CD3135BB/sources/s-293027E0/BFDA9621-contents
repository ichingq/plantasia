
#ARIMA + GARCH 

#source("fm_casestudy_fx_1.r")
# This command need be run only once and can be commented out afterward.
# If running
#The following commands re-load the data and provide details explaining the data.


# 0. Install/load libraries ----
source(file="InstallOrLoadLibraries.r")

# 0.2 Load R workspace created by script fm_casestudy_fx_1.r
#load(file="fm_casestudy_fx_1.Rdata")
# 1.0 Extract time series matrix of exchange rates for symbols given by list.symbol0 ----
#list.symbol0<-c("DEXUSEU")
#fxrates000<-fred.fxrates.00[,list.symbol0]


#Read fxt.csv created in mql4
fxrates = as.xts( 
  read.zoo(
    file="../../../AppData/Roaming/MetaQuotes/Terminal/3294B546D50FEEDA6BF3CFC7CF858DB7/MQL4/Files/fx/Bitcoin.csv", format="%Y.%m.%d", header=F, sep=";"
  )
)
fxrates000<-fxrates


dim(fxrates000)
head(fxrates000)
tail(fxrates000)

# Plot all data exchange rate time series
plot(as.xts(fxrates000))

#Cut the data to the last k, differentiate the log values of the series,
#set initial term to 0, and plot
#for(n in 0:50){
n=0
k = 110 +n*10 #size of the data to analyze
fxrates000.0<-fxrates000[((length(fxrates000) - k)):(length(fxrates000))]
fxrates000.0<-diff(log(fxrates000.0))
#fxrates000.0[2] = 0
fxrates000.0[1] = 0
plot(as.xts(fxrates000.0), main= "Log Diff TimeSeries", type ="o")
hist(fxrates000.0, nclass=100, main = "Log diff TimeSeries", xlab="log changes")

# Create the forecasts vector to store the predictions and the degrees
# of freedom of the t distribution
# windowLength = k+1 to get one forecast
# Get cumulative standard deviation using runSD - NOT USING THIS

windowLength = k+1
foreLength = length(fxrates000.0) - windowLength
forecasts <- vector(mode="character", length=foreLength)
ind <- vector(mode="numeric", length=100)
df0<-10 #fitdistr(x, "t")
# df0 = fitdistr((fxrates000.0),"t")
# df0 = df0[["estimate"]][["df"]]
# df0 = as.integer(df0) + 1
fixed.pars.df0=list(shape=df0)


for (d in 0:foreLength) {
  # Obtain the rolling window for this day
  fxrates000.0.Off.set = fxrates000.0[(1+d):(windowLength+d)]
  
  # Fit the ARMA model
  final.aic <- Inf
  final.order <- c(0,0,0)
  for (p in 0:10) for (q in 0:10) {
    if ( p == 0 && q == 0) {
      next
    }
    
    arimaFit = tryCatch( arima(fxrates000.0.Off.set, order=c(p, 0, q)),
                         error=function( err ) FALSE,
                         warning=function( err ) FALSE )
    
    if( !is.logical( arimaFit ) ) {
      current.aic <- AIC(arimaFit)
      if (current.aic < final.aic) {
        final.aic <- current.aic
        final.order <- c(p, 0, q)
        final.arima <- arima(fxrates000.0.Off.set, order=final.order)
      }
    } else {
      next
    }
  }
  
  # Specify and fit the GARCH model
  
  
  spec = ugarchspec(
    variance.model=list(garchOrder=c(1,1)),
    mean.model=list(armaOrder=c(final.order[1], final.order[3]), include.mean=T),
    distribution.model="std",
    fixed.pars=fixed.pars.df0
  )
  fit = tryCatch(
    ugarchfit(
      spec, fxrates000.0.Off.set, solver = 'hybrid'
    ), error=function(e) e, warning=function(w) w
  )
  
  # If the GARCH model does not converge, use ARMA model for prediction.
  # If the model doesn't predict a move outside one standard deviation of the error term
  # set direction to "0"
  # Else set the direction, "1" if the return is positive, "-1" if the return is negative
  
  # TO CONSIDER:
  # IF THE ARMA MODEL ERROR TERM SD < ARMA+GARCH MODEL ERROR TERM SD 
  # *** sd(fit@fit[["residuals"]]) < sd(final.arima[["residuals"]]) ***
  # CONSIDER USING ARMA MODEL FOR FORECASTING (IMPLEMENTED)
  
  if(is(fit, "warning")){ # || sd(fit@fit[["residuals"]]) > sd(final.arima[["residuals"]])) {
    
    ######
    
    fore = forecast(final.arima)
    ind[1] = fore[["mean"]][1]
    #cumsd = sd(final.arima[["residuals"]])
    cumsd = sd(fit@fit[["residuals"]])
    #residuals.mean = mean(final.arima[["residuals"]])
    residuals.mean = mean( fit@fit[["residuals"]])
    print("ARMA FORECAST")
    print(ind[1])
    
    if (ind[1] <= residuals.mean - cumsd){
      forecasts[d+1] = paste(colnames(ind), -1, sep=",")
      print(paste(index(fxrates000.0.Off.set[windowLength]), -1, sep=","))
      print(paste("Not differenciated time series value forecast: ", exp(ind[1]+log(tail(fxrates000, n=1)))))
      print(paste("ARMA error stendard deviation", sd(final.arima[["residuals"]])))
    }
    
    if (ind[1] >= residuals.mean + cumsd){
      forecasts[d+1] = paste(colnames(ind), 1, sep=",")
      print(paste(index(fxrates000.0.Off.set[windowLength]), 1, sep=","))
      print(paste("Not differenciated time series value forecast: ", exp(ind[1]+log(tail(fxrates000, n=1)))))
      print(paste("ARMA error stendard deviation", sd(final.arima[["residuals"]])))
    }
    
    if (ind[1] > residuals.mean - cumsd && ind[1] < residuals.mean + cumsd){
      forecasts[d+1] = paste(colnames(ind), 0, sep=",")
      print(paste(index(fxrates000.0.Off.set[windowLength]), 0, sep=","))
      print(paste("Not differenciated time series value forecast: ", exp(ind[1]+log(tail(fxrates000, n=1)))))
      print(paste("ARMA error stendard deviation", sd(final.arima[["residuals"]])))
    }
    
    ######
    
    # forecasts[d+1] = paste(index(fxrates000.0.Off.set[windowLength]), 0, sep=",")
    # print(paste(index(fxrates000.0.Off.set[windowLength]), 0, sep=","))
  } else {
    fore = ugarchforecast(fit, n.ahead=1)
    ind = fore@forecast$seriesFor
    cumsd = sd(fit@fit[["residuals"]])
    residuals.mean = mean((fit@fit[["residuals"]]))
    print("ARMA+GARCH FORECAST")
    print(ind[1]) 
  
  
    if (ind[1] <= residuals.mean - cumsd){
      forecasts[d+1] = paste(colnames(ind), -1, sep=",")
      print(paste(index(fxrates000.0.Off.set[windowLength]), -1, sep=","))
      print(paste("Not differenciated time series value forecast: ", exp(ind[1]+log(tail(fxrates000, n=1)))))
      print(paste("garch alpha+beta = ", fit@fit[["coef"]][["beta1"]]+fit@fit[["coef"]][["alpha1"]], sep=""))
      print(paste("garch error stendard deviation", sd(fit@fit[["residuals"]])))
  }
  
    if (ind[1] >= residuals.mean + cumsd){
      forecasts[d+1] = paste(colnames(ind), 1, sep=",")
      print(paste(index(fxrates000.0.Off.set[windowLength]), 1, sep=","))
      print(paste("Not differenciated time series value forecast: ", exp(ind[1]+log(tail(fxrates000, n=1)))))
      print(paste("garch alpha+beta = ", fit@fit[["coef"]][["beta1"]]+fit@fit[["coef"]][["alpha1"]], sep=""))
      print(paste("garch error stendard deviation", sd(fit@fit[["residuals"]])))
  }
  
    if (ind[1] > residuals.mean - cumsd && ind[1] < residuals.mean + cumsd){
      forecasts[d+1] = paste(colnames(ind), 0, sep=",")
      print(paste(index(fxrates000.0.Off.set[windowLength]), 0, sep=","))
      print(paste("Not differenciated time series value forecast: ", exp(ind[1]+log(tail(fxrates000, n=1)))))
      print(paste("garch alpha+beta = ", fit@fit[["coef"]][["beta1"]]+fit@fit[["coef"]][["alpha1"]], sep=""))
      print(paste("garch error stendard deviation", sd(fit@fit[["residuals"]])))
      
     
    }
    
    #forecasts[d+1] = paste(colnames(ind), ifelse(ind[1] < 0 - unname(tail(cumsd)), -1), sep=",")
    #print(paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")) 
  } 
  print("**************************")
}

plot(as.xts(fxrates000.0), main= "Log Diff TimeSeries", type ="o",lwd=1,col="black")
lines(fitted(fit),col="blue",lwd=1,type="o")
lines(fit@fit[["sigma"]],col="green")
#}
 #print(paste(exp(ind[1]+log(tail(fxrates000, n=1)))))
# Output the CSV file to "forecasts.csv"
write.csv(forecasts, file="forecasts_test.csv", row.names=FALSE)



