#Before running this file remember to run textexport.ex4 in MQL4/Scripts

arimagarch <- function(fxrates,k){
  fxrates000<-fxrates
  
  #Cut the data to the last k, differentiate the log values of the series,
  #set initial term to 0
  
  #k = 400 #size of the data to analyze
  fxrates000.0<-fxrates000[((length(fxrates000) - k)):(length(fxrates000))]
  fxrates000.0<-diff(log(fxrates000.0))
  fxrates000.0[1] = 0
  
  
  # Create the forecasts vector to store the predictions and the degrees
  # of freedom of the t distribution
  # Get cumulative standard deviation using runSD - NOT USING THIS
  
  windowLength = k+1
  foreLength = length(fxrates000.0) - windowLength
  forecasts <- vector(mode="character", length=foreLength)
  #foo <- vector(mode="character", length=foreLength)
  ind <- vector(mode="numeric", length=100)
  df0<-10 #fitdistr(x, "t")
  fixed.pars.df0=list(shape=df0)
  
  
  for (d in 0:foreLength) {
    # Obtain the EURUSD rolling window for this day
    fxrates000.0.Off.set = fxrates000.0[(1+d):(windowLength+d)]
    
    # Fit the ARIMA model
    final.aic <- Inf
    final.order <- c(0,0,0)
    for (p in 0:10) for (q in 0:10) {
      if ( p == 0 && q == 0) {
        next
      }
      
      arimaFit = tryCatch( arima(fxrates000.0.Off.set, order=c(p, 0, q)),
                           error=function( err ) FALSE,
                           warning=function( err ) FALSE )
      
      if( !is.logical( arimaFit ) ) {
        current.aic <- AIC(arimaFit)
        if (current.aic < final.aic) {
          final.aic <- current.aic
          final.order <- c(p, 0, q)
          final.arima <- arima(fxrates000.0.Off.set, order=final.order)
        }
      } else {
        next
      }
    }
    
    # Specify and fit the GARCH model
    
    
    spec = ugarchspec(
      variance.model=list(garchOrder=c(1,1)),
      mean.model=list(armaOrder=c(final.order[1], final.order[3]), include.mean=T),
      distribution.model="std",
      fixed.pars=fixed.pars.df0
    )
    fit = tryCatch(
      ugarchfit(
        spec, fxrates000.0.Off.set, solver = 'hybrid'
      ), error=function(e) e, warning=function(w) w
    )
    
    # If the GARCH model does not converge, set the direction to "0",
    # If the model doesn't predict a move outside one standard deviation of the error term
    # set direction to "0"
    # Else set the direction, "1" if the return is positive, "-1" if the return is negative
    
    if(is(fit, "warning")) {
      #forecasts[d+1] = paste(index(fxrates000.0.Off.set[windowLength]), 0, sep=",")
      forecast_arima = forecast(final.arima,1)
      forecast_arima_mean = forecast_arima[["mean"]]
      sdfar=sd(final.arima[["residuals"]])
      forecasts[d+1] = paste(index(fxrates000.0.Off.set[windowLength]), forecast_arima_mean[1], sdfar, sep=",")
      #print(paste(index(fxrates000.0.Off.set[windowLength]), 0, sep=","))
    } else {
      fore = ugarchforecast(fit, n.ahead=1)
      ind = fore@forecast$seriesFor
      cumsd = sd(fit@fit[["residuals"]])
      residuals.mean = mean((fit@fit[["residuals"]]))
      
      forecasts[d+1] = paste(colnames(ind), ind, cumsd, "1", sep=",") #The 1 means that garch (1,1) model is b
      #foo[d+1] = ind/cumsd
      #print(ind[1])
      
      # if (ind[1] <= residuals.mean - cumsd){
      #   forecasts[d+1] = paste(colnames(ind), -1, sep=",")
      #   forecasts[d+1] = paste(colnames(ind), -1, sep=",")
      #   #print(paste(index(fxrates000.0.Off.set[windowLength]), -1, sep=","))
      # }
      # 
      # if (ind[1] >= residuals.mean + cumsd){
      #   forecasts[d+1] = paste(colnames(ind), 1, sep=",")
      #   #print(paste(index(fxrates000.0.Off.set[windowLength]), 1, sep=","))
      # }
      # 
      # if (ind[1] > residuals.mean - cumsd && ind[1] < residuals.mean + cumsd){
      #   forecasts[d+1] = paste(colnames(ind), 0, sep=",")
      #   #print(paste(index(fxrates000.0.Off.set[windowLength]), 0, sep=","))
      # }
      
      #forecasts[d+1] = paste(colnames(ind), ifelse(ind[1] < 0 - unname(tail(cumsd)), -1), sep=",")
      #print(paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")) 
    }
  }
  
  # Output the CSV file to "forecasts.csv"
 # write.csv(forecasts, file="forecasts.csv", row.names=FALSE)
  return(forecasts)
}

# Seek path from MQL4/Files/fx folder

path = "../../../AppData/Roaming/MetaQuotes/Terminal/3294B546D50FEEDA6BF3CFC7CF858DB7/MQL4/Files/fx/"

# Read marketinfo.txt. File containing quotes names to predict
# And get size of marketinfo

#Use "marketinfo <- read.delim("marketinfo.txt", header = FALSE)" for a selection of quotes
#from metatrader files. Remember to create marketinfo.txt in your project folder.

marketinfo <- read.delim(paste(path,"marketinfo_clean.txt",sep=""),header = FALSE)
infolength = dim(marketinfo)
output <- vector(mode="character", length=infolength[1])


# For each quote, open the timeseries in the ***.csv, execute ARIMA+GARCH forecast
# and store it in "current". Paste in output[n]: Quote, Date, and Prediction

for (n in 1:infolength[1]){
  
  fxrates = as.xts(
    read.zoo(
      file=paste(path,marketinfo[n,1],".csv", sep = ""), format="%Y.%m.%d", header=F, sep=";"
    )
  )
  current = arimagarch(fxrates,100)
  output[n] = paste(marketinfo[n,1], ",",current, sep = "")
  #print(paste(marketinfo[n,1], current))
  print(output[n])
}


 #Export output to forecasts.csv
filename = paste("forecasts/forecast_", Sys.Date(), ".csv", sep="")
write.csv(output, file=filename, row.names=FALSE)
                                                                                                                                                                      
